diff --git a/dist/index.cjs b/dist/index.cjs
index bf7da635b18425dd8647f7be013899f1bb841142..b7fba1a90fec54a02242ed544a537e9ce3d7d896 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -32,16 +32,36 @@ var DEFAULT_HEADERS = {
 };
 var TRAILING_SLASH_RE = /\/*$/;
 function createClient(clientOptions = {}) {
-  const { fetch = globalThis.fetch, querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, ...options } = clientOptions;
-  async function coreFetch(url, fetchOptions) {
-    const { headers, body: requestBody, params = {}, parseAs = "json", querySerializer = globalQuerySerializer ?? defaultQuerySerializer, bodySerializer = globalBodySerializer ?? defaultBodySerializer, ...init } = fetchOptions || {};
-    const finalURL = createFinalURL(url, { baseUrl: options.baseUrl, params, querySerializer });
-    const finalHeaders = mergeHeaders(DEFAULT_HEADERS, clientOptions?.headers, headers, params.header);
-    const requestInit = { redirect: "follow", ...options, ...init, headers: finalHeaders };
+  const {
+    querySerializer: globalQuerySerializer,
+    bodySerializer: globalBodySerializer,
+    ...options
+  } = clientOptions;
+  async function coreFetch(url, fetchOptions, fetch = globalThis.fetch) {
+    const {
+      headers,
+      body: requestBody,
+      params = {},
+      parseAs = "json",
+      querySerializer = globalQuerySerializer ?? defaultQuerySerializer,
+      bodySerializer = globalBodySerializer ?? defaultBodySerializer,
+      ...init
+    } = fetchOptions || {};
+    const finalURL = createFinalURL(url, {
+      baseUrl: options.baseUrl,
+      params,
+      querySerializer
+    });
+    const finalHeaders = mergeHeaders(
+      DEFAULT_HEADERS,
+      clientOptions?.headers,
+      headers,
+      params.header
+    );
+    const requestInit = Object.assign(init, options, { headers: finalHeaders });
+    requestInit.redirect ??= "follow";
     if (requestBody)
       requestInit.body = bodySerializer(requestBody);
-    if (requestInit.body instanceof FormData)
-      finalHeaders.delete("Content-Type");
     const response = await fetch(finalURL, requestInit);
     if (response.status === 204 || response.headers.get("Content-Length") === "0") {
       return response.ok ? { data: {}, response } : { error: {}, response };
@@ -64,36 +84,44 @@ function createClient(clientOptions = {}) {
   }
   return {
     /** Call a GET endpoint */
-    async GET(url, init) {
-      return coreFetch(url, { ...init, method: "GET" });
+    async GET(url, init, fetch = globalThis.fetch) {
+      init.method = "GET";
+      return coreFetch(url, init, fetch);
     },
     /** Call a PUT endpoint */
-    async PUT(url, init) {
-      return coreFetch(url, { ...init, method: "PUT" });
+    async PUT(url, init, fetch = globalThis.fetch) {
+      init.method = "PUT";
+      return coreFetch(url, init), fetch;
     },
     /** Call a POST endpoint */
-    async POST(url, init) {
-      return coreFetch(url, { ...init, method: "POST" });
+    async POST(url, init, fetch = globalThis.fetch) {
+      init.method = "POST";
+      return coreFetch(url, init, fetch);
     },
     /** Call a DELETE endpoint */
-    async DELETE(url, init) {
-      return coreFetch(url, { ...init, method: "DELETE" });
+    async DELETE(url, init, fetch = globalThis.fetch) {
+      init.method = "DELETE";
+      return coreFetch(url, init, fetch);
     },
     /** Call a OPTIONS endpoint */
-    async OPTIONS(url, init) {
-      return coreFetch(url, { ...init, method: "OPTIONS" });
+    async OPTIONS(url, init, fetch = globalThis.fetch) {
+      init.method = "OPTIONS";
+      return coreFetch(url, init, fetch);
     },
     /** Call a HEAD endpoint */
-    async HEAD(url, init) {
-      return coreFetch(url, { ...init, method: "HEAD" });
+    async HEAD(url, init, fetch = globalThis.fetch) {
+      init.method = "HEAD";
+      return coreFetch(url, init, fetch);
     },
     /** Call a PATCH endpoint */
-    async PATCH(url, init) {
-      return coreFetch(url, { ...init, method: "PATCH" });
+    async PATCH(url, init, fetch = globalThis.fetch) {
+      init.method = "PATCH";
+      return coreFetch(url, init, fetch);
     },
     /** Call a TRACE endpoint */
-    async TRACE(url, init) {
-      return coreFetch(url, { ...init, method: "TRACE" });
+    async TRACE(url, init, fetch = globalThis.fetch) {
+      init.method = "TRACE";
+      return coreFetch(url, init, fetch);
     }
   };
 }
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 5403066621b7b4ff4517a9bb3c325bb26f47cfb0..d2221dd771e14468015fe01277bbb0557d8b0a7e 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -3,8 +3,6 @@ import type { ErrorResponse, SuccessResponse, FilterKeys, MediaType, PathsWithMe
 interface ClientOptions extends Omit<RequestInit, "headers"> {
     /** set the common root URL for all API requests */
     baseUrl?: string;
-    /** custom fetch (defaults to globalThis.fetch) */
-    fetch?: typeof fetch;
     /** global querySerializer */
     querySerializer?: QuerySerializer<unknown>;
     /** global bodySerializer */
@@ -51,21 +49,21 @@ export type RequestOptions<T> = ParamsOption<T> & RequestBodyOption<T> & {
 };
 export default function createClient<Paths extends {}>(clientOptions?: ClientOptions): {
     /** Call a GET endpoint */
-    GET<P extends PathsWithMethod<Paths, "get">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "get">>): Promise<FetchResponse<"get" extends infer T ? T extends "get" ? T extends keyof Paths[P] ? Paths[P][T] : unknown : never : never>>;
+    GET<P extends PathsWithMethod<Paths, "get">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "get">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"get" extends infer T ? T extends "get" ? T extends keyof Paths[P] ? Paths[P][T] : unknown : never : never>>;
     /** Call a PUT endpoint */
-    PUT<P_1 extends PathsWithMethod<Paths, "put">>(url: P_1, init: FetchOptions<FilterKeys<Paths[P_1], "put">>): Promise<FetchResponse<"put" extends infer T_1 ? T_1 extends "put" ? T_1 extends keyof Paths[P_1] ? Paths[P_1][T_1] : unknown : never : never>>;
+    PUT<P_1 extends PathsWithMethod<Paths, "put">>(url: P_1, init: FetchOptions<FilterKeys<Paths[P_1], "put">>, fetch?: typeof globalThis.fetch): Promise<typeof globalThis.fetch>;
     /** Call a POST endpoint */
-    POST<P_2 extends PathsWithMethod<Paths, "post">>(url: P_2, init: FetchOptions<FilterKeys<Paths[P_2], "post">>): Promise<FetchResponse<"post" extends infer T_2 ? T_2 extends "post" ? T_2 extends keyof Paths[P_2] ? Paths[P_2][T_2] : unknown : never : never>>;
+    POST<P_2 extends PathsWithMethod<Paths, "post">>(url: P_2, init: FetchOptions<FilterKeys<Paths[P_2], "post">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"post" extends infer T_1 ? T_1 extends "post" ? T_1 extends keyof Paths[P_2] ? Paths[P_2][T_1] : unknown : never : never>>;
     /** Call a DELETE endpoint */
-    DELETE<P_3 extends PathsWithMethod<Paths, "delete">>(url: P_3, init: FetchOptions<FilterKeys<Paths[P_3], "delete">>): Promise<FetchResponse<"delete" extends infer T_3 ? T_3 extends "delete" ? T_3 extends keyof Paths[P_3] ? Paths[P_3][T_3] : unknown : never : never>>;
+    DELETE<P_3 extends PathsWithMethod<Paths, "delete">>(url: P_3, init: FetchOptions<FilterKeys<Paths[P_3], "delete">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"delete" extends infer T_2 ? T_2 extends "delete" ? T_2 extends keyof Paths[P_3] ? Paths[P_3][T_2] : unknown : never : never>>;
     /** Call a OPTIONS endpoint */
-    OPTIONS<P_4 extends PathsWithMethod<Paths, "options">>(url: P_4, init: FetchOptions<FilterKeys<Paths[P_4], "options">>): Promise<FetchResponse<"options" extends infer T_4 ? T_4 extends "options" ? T_4 extends keyof Paths[P_4] ? Paths[P_4][T_4] : unknown : never : never>>;
+    OPTIONS<P_4 extends PathsWithMethod<Paths, "options">>(url: P_4, init: FetchOptions<FilterKeys<Paths[P_4], "options">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"options" extends infer T_3 ? T_3 extends "options" ? T_3 extends keyof Paths[P_4] ? Paths[P_4][T_3] : unknown : never : never>>;
     /** Call a HEAD endpoint */
-    HEAD<P_5 extends PathsWithMethod<Paths, "head">>(url: P_5, init: FetchOptions<FilterKeys<Paths[P_5], "head">>): Promise<FetchResponse<"head" extends infer T_5 ? T_5 extends "head" ? T_5 extends keyof Paths[P_5] ? Paths[P_5][T_5] : unknown : never : never>>;
+    HEAD<P_5 extends PathsWithMethod<Paths, "head">>(url: P_5, init: FetchOptions<FilterKeys<Paths[P_5], "head">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"head" extends infer T_4 ? T_4 extends "head" ? T_4 extends keyof Paths[P_5] ? Paths[P_5][T_4] : unknown : never : never>>;
     /** Call a PATCH endpoint */
-    PATCH<P_6 extends PathsWithMethod<Paths, "patch">>(url: P_6, init: FetchOptions<FilterKeys<Paths[P_6], "patch">>): Promise<FetchResponse<"patch" extends infer T_6 ? T_6 extends "patch" ? T_6 extends keyof Paths[P_6] ? Paths[P_6][T_6] : unknown : never : never>>;
+    PATCH<P_6 extends PathsWithMethod<Paths, "patch">>(url: P_6, init: FetchOptions<FilterKeys<Paths[P_6], "patch">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"patch" extends infer T_5 ? T_5 extends "patch" ? T_5 extends keyof Paths[P_6] ? Paths[P_6][T_5] : unknown : never : never>>;
     /** Call a TRACE endpoint */
-    TRACE<P_7 extends PathsWithMethod<Paths, "trace">>(url: P_7, init: FetchOptions<FilterKeys<Paths[P_7], "trace">>): Promise<FetchResponse<"trace" extends infer T_7 ? T_7 extends "trace" ? T_7 extends keyof Paths[P_7] ? Paths[P_7][T_7] : unknown : never : never>>;
+    TRACE<P_7 extends PathsWithMethod<Paths, "trace">>(url: P_7, init: FetchOptions<FilterKeys<Paths[P_7], "trace">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"trace" extends infer T_6 ? T_6 extends "trace" ? T_6 extends keyof Paths[P_7] ? Paths[P_7][T_6] : unknown : never : never>>;
 };
 /** serialize query params to string */
 export declare function defaultQuerySerializer<T = unknown>(q: T): string;
diff --git a/dist/index.js b/dist/index.js
index 59b3aa56d4a795021e89bd12bb06476ee37bdd32..6978e0c5cf81a16f0fc2324bad1f44ec750025f7 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -4,31 +4,39 @@ const DEFAULT_HEADERS = {
 };
 const TRAILING_SLASH_RE = /\/*$/;
 export default function createClient(clientOptions = {}) {
-    const { fetch = globalThis.fetch, querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, ...options } = clientOptions;
-    async function coreFetch(url, fetchOptions) {
+    const { querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, ...options } = clientOptions;
+    async function coreFetch(url, fetchOptions, fetch = globalThis.fetch) {
         const { headers, body: requestBody, params = {}, parseAs = "json", querySerializer = globalQuerySerializer ?? defaultQuerySerializer, bodySerializer = globalBodySerializer ?? defaultBodySerializer, ...init } = fetchOptions || {};
         // URL
-        const finalURL = createFinalURL(url, { baseUrl: options.baseUrl, params, querySerializer });
+        const finalURL = createFinalURL(url, {
+            baseUrl: options.baseUrl,
+            params,
+            querySerializer,
+        });
         const finalHeaders = mergeHeaders(DEFAULT_HEADERS, clientOptions?.headers, headers, params.header);
         // fetch!
-        const requestInit = { redirect: "follow", ...options, ...init, headers: finalHeaders };
+        const requestInit = Object.assign(init, options, { headers: finalHeaders });
+        requestInit.redirect ??= "follow";
         if (requestBody)
             requestInit.body = bodySerializer(requestBody);
         // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression
-        if (requestInit.body instanceof FormData)
-            finalHeaders.delete("Content-Type");
+        // # Removed unnecessary check because we don't use FormData anyway - by Evgenii@HugeLetters
+        // if (requestInit.body instanceof FormData) finalHeaders.delete("Content-Type");
         const response = await fetch(finalURL, requestInit);
         // handle empty content
         // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed
         if (response.status === 204 || response.headers.get("Content-Length") === "0") {
-            return response.ok ? { data: {}, response: response } : { error: {}, response: response };
+            return response.ok
+                ? { data: {}, response: response }
+                : { error: {}, response: response };
         }
         // parse response (falling back to .text() when necessary)
         if (response.ok) {
             let data = response.body;
             if (parseAs !== "stream") {
                 const cloned = response.clone();
-                data = typeof cloned[parseAs] === "function" ? await cloned[parseAs]() : await cloned.text();
+                data =
+                    typeof cloned[parseAs] === "function" ? await cloned[parseAs]() : await cloned.text();
             }
             return { data, response: response };
         }
@@ -44,36 +52,44 @@ export default function createClient(clientOptions = {}) {
     }
     return {
         /** Call a GET endpoint */
-        async GET(url, init) {
-            return coreFetch(url, { ...init, method: "GET" });
+        async GET(url, init, fetch = globalThis.fetch) {
+            init.method = "GET";
+            return coreFetch(url, init, fetch);
         },
         /** Call a PUT endpoint */
-        async PUT(url, init) {
-            return coreFetch(url, { ...init, method: "PUT" });
+        async PUT(url, init, fetch = globalThis.fetch) {
+            init.method = "PUT";
+            return coreFetch(url, init), fetch;
         },
         /** Call a POST endpoint */
-        async POST(url, init) {
-            return coreFetch(url, { ...init, method: "POST" });
+        async POST(url, init, fetch = globalThis.fetch) {
+            init.method = "POST";
+            return coreFetch(url, init, fetch);
         },
         /** Call a DELETE endpoint */
-        async DELETE(url, init) {
-            return coreFetch(url, { ...init, method: "DELETE" });
+        async DELETE(url, init, fetch = globalThis.fetch) {
+            init.method = "DELETE";
+            return coreFetch(url, init, fetch);
         },
         /** Call a OPTIONS endpoint */
-        async OPTIONS(url, init) {
-            return coreFetch(url, { ...init, method: "OPTIONS" });
+        async OPTIONS(url, init, fetch = globalThis.fetch) {
+            init.method = "OPTIONS";
+            return coreFetch(url, init, fetch);
         },
         /** Call a HEAD endpoint */
-        async HEAD(url, init) {
-            return coreFetch(url, { ...init, method: "HEAD" });
+        async HEAD(url, init, fetch = globalThis.fetch) {
+            init.method = "HEAD";
+            return coreFetch(url, init, fetch);
         },
         /** Call a PATCH endpoint */
-        async PATCH(url, init) {
-            return coreFetch(url, { ...init, method: "PATCH" });
+        async PATCH(url, init, fetch = globalThis.fetch) {
+            init.method = "PATCH";
+            return coreFetch(url, init, fetch);
         },
         /** Call a TRACE endpoint */
-        async TRACE(url, init) {
-            return coreFetch(url, { ...init, method: "TRACE" });
+        async TRACE(url, init, fetch = globalThis.fetch) {
+            init.method = "TRACE";
+            return coreFetch(url, init, fetch);
         },
     };
 }
diff --git a/dist/index.min.d.ts b/dist/index.min.d.ts
index 5403066621b7b4ff4517a9bb3c325bb26f47cfb0..d2221dd771e14468015fe01277bbb0557d8b0a7e 100644
--- a/dist/index.min.d.ts
+++ b/dist/index.min.d.ts
@@ -3,8 +3,6 @@ import type { ErrorResponse, SuccessResponse, FilterKeys, MediaType, PathsWithMe
 interface ClientOptions extends Omit<RequestInit, "headers"> {
     /** set the common root URL for all API requests */
     baseUrl?: string;
-    /** custom fetch (defaults to globalThis.fetch) */
-    fetch?: typeof fetch;
     /** global querySerializer */
     querySerializer?: QuerySerializer<unknown>;
     /** global bodySerializer */
@@ -51,21 +49,21 @@ export type RequestOptions<T> = ParamsOption<T> & RequestBodyOption<T> & {
 };
 export default function createClient<Paths extends {}>(clientOptions?: ClientOptions): {
     /** Call a GET endpoint */
-    GET<P extends PathsWithMethod<Paths, "get">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "get">>): Promise<FetchResponse<"get" extends infer T ? T extends "get" ? T extends keyof Paths[P] ? Paths[P][T] : unknown : never : never>>;
+    GET<P extends PathsWithMethod<Paths, "get">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "get">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"get" extends infer T ? T extends "get" ? T extends keyof Paths[P] ? Paths[P][T] : unknown : never : never>>;
     /** Call a PUT endpoint */
-    PUT<P_1 extends PathsWithMethod<Paths, "put">>(url: P_1, init: FetchOptions<FilterKeys<Paths[P_1], "put">>): Promise<FetchResponse<"put" extends infer T_1 ? T_1 extends "put" ? T_1 extends keyof Paths[P_1] ? Paths[P_1][T_1] : unknown : never : never>>;
+    PUT<P_1 extends PathsWithMethod<Paths, "put">>(url: P_1, init: FetchOptions<FilterKeys<Paths[P_1], "put">>, fetch?: typeof globalThis.fetch): Promise<typeof globalThis.fetch>;
     /** Call a POST endpoint */
-    POST<P_2 extends PathsWithMethod<Paths, "post">>(url: P_2, init: FetchOptions<FilterKeys<Paths[P_2], "post">>): Promise<FetchResponse<"post" extends infer T_2 ? T_2 extends "post" ? T_2 extends keyof Paths[P_2] ? Paths[P_2][T_2] : unknown : never : never>>;
+    POST<P_2 extends PathsWithMethod<Paths, "post">>(url: P_2, init: FetchOptions<FilterKeys<Paths[P_2], "post">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"post" extends infer T_1 ? T_1 extends "post" ? T_1 extends keyof Paths[P_2] ? Paths[P_2][T_1] : unknown : never : never>>;
     /** Call a DELETE endpoint */
-    DELETE<P_3 extends PathsWithMethod<Paths, "delete">>(url: P_3, init: FetchOptions<FilterKeys<Paths[P_3], "delete">>): Promise<FetchResponse<"delete" extends infer T_3 ? T_3 extends "delete" ? T_3 extends keyof Paths[P_3] ? Paths[P_3][T_3] : unknown : never : never>>;
+    DELETE<P_3 extends PathsWithMethod<Paths, "delete">>(url: P_3, init: FetchOptions<FilterKeys<Paths[P_3], "delete">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"delete" extends infer T_2 ? T_2 extends "delete" ? T_2 extends keyof Paths[P_3] ? Paths[P_3][T_2] : unknown : never : never>>;
     /** Call a OPTIONS endpoint */
-    OPTIONS<P_4 extends PathsWithMethod<Paths, "options">>(url: P_4, init: FetchOptions<FilterKeys<Paths[P_4], "options">>): Promise<FetchResponse<"options" extends infer T_4 ? T_4 extends "options" ? T_4 extends keyof Paths[P_4] ? Paths[P_4][T_4] : unknown : never : never>>;
+    OPTIONS<P_4 extends PathsWithMethod<Paths, "options">>(url: P_4, init: FetchOptions<FilterKeys<Paths[P_4], "options">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"options" extends infer T_3 ? T_3 extends "options" ? T_3 extends keyof Paths[P_4] ? Paths[P_4][T_3] : unknown : never : never>>;
     /** Call a HEAD endpoint */
-    HEAD<P_5 extends PathsWithMethod<Paths, "head">>(url: P_5, init: FetchOptions<FilterKeys<Paths[P_5], "head">>): Promise<FetchResponse<"head" extends infer T_5 ? T_5 extends "head" ? T_5 extends keyof Paths[P_5] ? Paths[P_5][T_5] : unknown : never : never>>;
+    HEAD<P_5 extends PathsWithMethod<Paths, "head">>(url: P_5, init: FetchOptions<FilterKeys<Paths[P_5], "head">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"head" extends infer T_4 ? T_4 extends "head" ? T_4 extends keyof Paths[P_5] ? Paths[P_5][T_4] : unknown : never : never>>;
     /** Call a PATCH endpoint */
-    PATCH<P_6 extends PathsWithMethod<Paths, "patch">>(url: P_6, init: FetchOptions<FilterKeys<Paths[P_6], "patch">>): Promise<FetchResponse<"patch" extends infer T_6 ? T_6 extends "patch" ? T_6 extends keyof Paths[P_6] ? Paths[P_6][T_6] : unknown : never : never>>;
+    PATCH<P_6 extends PathsWithMethod<Paths, "patch">>(url: P_6, init: FetchOptions<FilterKeys<Paths[P_6], "patch">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"patch" extends infer T_5 ? T_5 extends "patch" ? T_5 extends keyof Paths[P_6] ? Paths[P_6][T_5] : unknown : never : never>>;
     /** Call a TRACE endpoint */
-    TRACE<P_7 extends PathsWithMethod<Paths, "trace">>(url: P_7, init: FetchOptions<FilterKeys<Paths[P_7], "trace">>): Promise<FetchResponse<"trace" extends infer T_7 ? T_7 extends "trace" ? T_7 extends keyof Paths[P_7] ? Paths[P_7][T_7] : unknown : never : never>>;
+    TRACE<P_7 extends PathsWithMethod<Paths, "trace">>(url: P_7, init: FetchOptions<FilterKeys<Paths[P_7], "trace">>, fetch?: typeof globalThis.fetch): Promise<FetchResponse<"trace" extends infer T_6 ? T_6 extends "trace" ? T_6 extends keyof Paths[P_7] ? Paths[P_7][T_6] : unknown : never : never>>;
 };
 /** serialize query params to string */
 export declare function defaultQuerySerializer<T = unknown>(q: T): string;
diff --git a/dist/index.min.js b/dist/index.min.js
index f6785d94824b6e8a6b615d4bbf4eebee633e8ac4..8f8abe0a8126cb485b58b181aa1752911cd45b9b 100644
--- a/dist/index.min.js
+++ b/dist/index.min.js
@@ -1 +1 @@
-var x={"Content-Type":"application/json"},S=/\/*$/;function g(s={}){let{fetch:r=globalThis.fetch,querySerializer:n,bodySerializer:a,...p}=s;async function o(e,t){let{headers:T,body:u,params:l={},parseAs:d="json",querySerializer:O=n??F,bodySerializer:R=a??q,...b}=t||{},m=M(e,{baseUrl:p.baseUrl,params:l,querySerializer:O}),P=z(x,s?.headers,T,l.header),y={redirect:"follow",...p,...b,headers:P};u&&(y.body=R(u)),y.body instanceof FormData&&P.delete("Content-Type");let i=await r(m,y);if(i.status===204||i.headers.get("Content-Length")==="0")return i.ok?{data:{},response:i}:{error:{},response:i};if(i.ok){let f=i.body;if(d!=="stream"){let c=i.clone();f=typeof c[d]=="function"?await c[d]():await c.text()}return{data:f,response:i}}let h={};try{h=await i.clone().json()}catch{h=await i.clone().text()}return{error:h,response:i}}return{async GET(e,t){return o(e,{...t,method:"GET"})},async PUT(e,t){return o(e,{...t,method:"PUT"})},async POST(e,t){return o(e,{...t,method:"POST"})},async DELETE(e,t){return o(e,{...t,method:"DELETE"})},async OPTIONS(e,t){return o(e,{...t,method:"OPTIONS"})},async HEAD(e,t){return o(e,{...t,method:"HEAD"})},async PATCH(e,t){return o(e,{...t,method:"PATCH"})},async TRACE(e,t){return o(e,{...t,method:"TRACE"})}}}function F(s){let r=new URLSearchParams;if(s&&typeof s=="object")for(let[n,a]of Object.entries(s))a!=null&&r.set(n,a);return r.toString()}function q(s){return JSON.stringify(s)}function M(s,r){let n=`${r.baseUrl?r.baseUrl.replace(S,""):""}${s}`;if(r.params.path)for(let[a,p]of Object.entries(r.params.path))n=n.replace(`{${a}}`,encodeURIComponent(String(p)));if(r.params.query){let a=r.querySerializer(r.params.query);a&&(n+=`?${a}`)}return n}function z(...s){let r=new Headers;for(let n of s){if(!n||typeof n!="object")continue;let a=n instanceof Headers?n.entries():Object.entries(n);for(let[p,o]of a)o===null?r.delete(p):o!==void 0&&r.set(p,o)}return r}export{M as createFinalURL,g as default,q as defaultBodySerializer,F as defaultQuerySerializer,z as mergeHeaders};
+var g={"Content-Type":"application/json"},m=/\/*$/;function S(i={}){let{querySerializer:r,bodySerializer:n,...a}=i;async function o(t,e,s=globalThis.fetch){let{headers:f,body:c,params:u={},parseAs:d="json",querySerializer:T=r??F,bodySerializer:O=n??q,...b}=e||{},R=M(t,{baseUrl:a.baseUrl,params:u,querySerializer:T}),x=z(g,i?.headers,f,u.header),h=Object.assign(b,a,{headers:x});h.redirect??="follow",c&&(h.body=O(c));let p=await s(R,h);if(p.status===204||p.headers.get("Content-Length")==="0")return p.ok?{data:{},response:p}:{error:{},response:p};if(p.ok){let P=p.body;if(d!=="stream"){let l=p.clone();P=typeof l[d]=="function"?await l[d]():await l.text()}return{data:P,response:p}}let y={};try{y=await p.clone().json()}catch{y=await p.clone().text()}return{error:y,response:p}}return{async GET(t,e,s=globalThis.fetch){return e.method="GET",o(t,e,s)},async PUT(t,e,s=globalThis.fetch){return e.method="PUT",o(t,e),s},async POST(t,e,s=globalThis.fetch){return e.method="POST",o(t,e,s)},async DELETE(t,e,s=globalThis.fetch){return e.method="DELETE",o(t,e,s)},async OPTIONS(t,e,s=globalThis.fetch){return e.method="OPTIONS",o(t,e,s)},async HEAD(t,e,s=globalThis.fetch){return e.method="HEAD",o(t,e,s)},async PATCH(t,e,s=globalThis.fetch){return e.method="PATCH",o(t,e,s)},async TRACE(t,e,s=globalThis.fetch){return e.method="TRACE",o(t,e,s)}}}function F(i){let r=new URLSearchParams;if(i&&typeof i=="object")for(let[n,a]of Object.entries(i))a!=null&&r.set(n,a);return r.toString()}function q(i){return JSON.stringify(i)}function M(i,r){let n=`${r.baseUrl?r.baseUrl.replace(m,""):""}${i}`;if(r.params.path)for(let[a,o]of Object.entries(r.params.path))n=n.replace(`{${a}}`,encodeURIComponent(String(o)));if(r.params.query){let a=r.querySerializer(r.params.query);a&&(n+=`?${a}`)}return n}function z(...i){let r=new Headers;for(let n of i){if(!n||typeof n!="object")continue;let a=n instanceof Headers?n.entries():Object.entries(n);for(let[o,t]of a)t===null?r.delete(o):t!==void 0&&r.set(o,t)}return r}export{M as createFinalURL,S as default,q as defaultBodySerializer,F as defaultQuerySerializer,z as mergeHeaders};
diff --git a/src/index.ts b/src/index.ts
index 619f82a8582e984f79ef13e9c9f6712050083411..67e2ce116448f69662096539df71fba31e72ab95 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,4 +1,13 @@
-import type { ErrorResponse, HttpMethod, SuccessResponse, FilterKeys, MediaType, PathsWithMethod, ResponseObjectMap, OperationRequestBodyContent } from "openapi-typescript-helpers";
+import type {
+  ErrorResponse,
+  HttpMethod,
+  SuccessResponse,
+  FilterKeys,
+  MediaType,
+  PathsWithMethod,
+  ResponseObjectMap,
+  OperationRequestBodyContent,
+} from "openapi-typescript-helpers";
 
 // settings & const
 const DEFAULT_HEADERS = {
@@ -14,8 +23,6 @@ const TRAILING_SLASH_RE = /\/*$/;
 interface ClientOptions extends Omit<RequestInit, "headers"> {
   /** set the common root URL for all API requests */
   baseUrl?: string;
-  /** custom fetch (defaults to globalThis.fetch) */
-  fetch?: typeof fetch;
   /** global querySerializer */
   querySerializer?: QuerySerializer<unknown>;
   /** global bodySerializer */
@@ -23,19 +30,39 @@ interface ClientOptions extends Omit<RequestInit, "headers"> {
   // headers override to make typing friendlier
   headers?: HeadersOptions;
 }
-export type HeadersOptions = HeadersInit | Record<string, string | number | boolean | null | undefined>;
-export type QuerySerializer<T> = (query: T extends { parameters: any } ? NonNullable<T["parameters"]["query"]> : Record<string, unknown>) => string;
+export type HeadersOptions =
+  | HeadersInit
+  | Record<string, string | number | boolean | null | undefined>;
+export type QuerySerializer<T> = (
+  query: T extends { parameters: any }
+    ? NonNullable<T["parameters"]["query"]>
+    : Record<string, unknown>
+) => string;
 export type BodySerializer<T> = (body: OperationRequestBodyContent<T>) => any;
 export type ParseAs = "json" | "text" | "blob" | "arrayBuffer" | "stream";
 export interface DefaultParamsOption {
   params?: { query?: Record<string, unknown> };
 }
-export type ParamsOption<T> = T extends { parameters: any } ? { params: NonNullable<T["parameters"]> } : DefaultParamsOption;
-export type RequestBodyOption<T> = OperationRequestBodyContent<T> extends never ? { body?: never } : undefined extends OperationRequestBodyContent<T> ? { body?: OperationRequestBodyContent<T> } : { body: OperationRequestBodyContent<T> };
+export type ParamsOption<T> = T extends { parameters: any }
+  ? { params: NonNullable<T["parameters"]> }
+  : DefaultParamsOption;
+export type RequestBodyOption<T> = OperationRequestBodyContent<T> extends never
+  ? { body?: never }
+  : undefined extends OperationRequestBodyContent<T>
+  ? { body?: OperationRequestBodyContent<T> }
+  : { body: OperationRequestBodyContent<T> };
 export type FetchOptions<T> = RequestOptions<T> & Omit<RequestInit, "body">;
 export type FetchResponse<T> =
-  | { data: FilterKeys<SuccessResponse<ResponseObjectMap<T>>, MediaType>; error?: never; response: Response }
-  | { data?: never; error: FilterKeys<ErrorResponse<ResponseObjectMap<T>>, MediaType>; response: Response };
+  | {
+      data: FilterKeys<SuccessResponse<ResponseObjectMap<T>>, MediaType>;
+      error?: never;
+      response: Response;
+    }
+  | {
+      data?: never;
+      error: FilterKeys<ErrorResponse<ResponseObjectMap<T>>, MediaType>;
+      response: Response;
+    };
 export type RequestOptions<T> = ParamsOption<T> &
   RequestBodyOption<T> & {
     querySerializer?: QuerySerializer<T>;
@@ -44,26 +71,56 @@ export type RequestOptions<T> = ParamsOption<T> &
   };
 
 export default function createClient<Paths extends {}>(clientOptions: ClientOptions = {}) {
-  const { fetch = globalThis.fetch, querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, ...options } = clientOptions;
+  const {
+    querySerializer: globalQuerySerializer,
+    bodySerializer: globalBodySerializer,
+    ...options
+  } = clientOptions;
 
-  async function coreFetch<P extends keyof Paths, M extends HttpMethod>(url: P, fetchOptions: FetchOptions<M extends keyof Paths[P] ? Paths[P][M] : never>): Promise<FetchResponse<M extends keyof Paths[P] ? Paths[P][M] : unknown>> {
-    const { headers, body: requestBody, params = {}, parseAs = "json", querySerializer = globalQuerySerializer ?? defaultQuerySerializer, bodySerializer = globalBodySerializer ?? defaultBodySerializer, ...init } = fetchOptions || {};
+  async function coreFetch<P extends keyof Paths, M extends HttpMethod>(
+    url: P,
+    fetchOptions: FetchOptions<M extends keyof Paths[P] ? Paths[P][M] : never>,
+    fetch = globalThis.fetch
+  ): Promise<FetchResponse<M extends keyof Paths[P] ? Paths[P][M] : unknown>> {
+    const {
+      headers,
+      body: requestBody,
+      params = {},
+      parseAs = "json",
+      querySerializer = globalQuerySerializer ?? defaultQuerySerializer,
+      bodySerializer = globalBodySerializer ?? defaultBodySerializer,
+      ...init
+    } = fetchOptions || {};
 
     // URL
-    const finalURL = createFinalURL(url as string, { baseUrl: options.baseUrl, params, querySerializer });
-    const finalHeaders = mergeHeaders(DEFAULT_HEADERS, clientOptions?.headers, headers, (params as any).header);
+    const finalURL = createFinalURL(url as string, {
+      baseUrl: options.baseUrl,
+      params,
+      querySerializer,
+    });
+    const finalHeaders = mergeHeaders(
+      DEFAULT_HEADERS,
+      clientOptions?.headers,
+      headers,
+      (params as any).header
+    );
 
     // fetch!
-    const requestInit: RequestInit = { redirect: "follow", ...options, ...init, headers: finalHeaders };
+    const requestInit: RequestInit = Object.assign(init, options, { headers: finalHeaders });
+    requestInit.redirect ??= "follow";
+
     if (requestBody) requestInit.body = bodySerializer(requestBody as any);
     // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression
-    if (requestInit.body instanceof FormData) finalHeaders.delete("Content-Type");
+    // # Removed unnecessary check because we don't use FormData anyway - by Evgenii@HugeLetters
+    // if (requestInit.body instanceof FormData) finalHeaders.delete("Content-Type");
     const response = await fetch(finalURL, requestInit);
 
     // handle empty content
     // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed
     if (response.status === 204 || response.headers.get("Content-Length") === "0") {
-      return response.ok ? { data: {} as any, response: response as any } : { error: {} as any, response: response as any };
+      return response.ok
+        ? { data: {} as any, response: response as any }
+        : { error: {} as any, response: response as any };
     }
 
     // parse response (falling back to .text() when necessary)
@@ -71,7 +128,8 @@ export default function createClient<Paths extends {}>(clientOptions: ClientOpti
       let data: any = response.body;
       if (parseAs !== "stream") {
         const cloned = response.clone();
-        data = typeof cloned[parseAs] === "function" ? await cloned[parseAs]() : await cloned.text();
+        data =
+          typeof cloned[parseAs] === "function" ? await cloned[parseAs]() : await cloned.text();
       }
       return { data, response: response as any };
     }
@@ -88,36 +146,76 @@ export default function createClient<Paths extends {}>(clientOptions: ClientOpti
 
   return {
     /** Call a GET endpoint */
-    async GET<P extends PathsWithMethod<Paths, "get">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "get">>) {
-      return coreFetch<P, "get">(url, { ...init, method: "GET" } as any);
+    async GET<P extends PathsWithMethod<Paths, "get">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "get">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "GET";
+      return coreFetch<P, "get">(url, init as any, fetch);
     },
     /** Call a PUT endpoint */
-    async PUT<P extends PathsWithMethod<Paths, "put">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "put">>) {
-      return coreFetch<P, "put">(url, { ...init, method: "PUT" } as any);
+    async PUT<P extends PathsWithMethod<Paths, "put">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "put">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "PUT";
+      return coreFetch<P, "put">(url, init as any), fetch;
     },
     /** Call a POST endpoint */
-    async POST<P extends PathsWithMethod<Paths, "post">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "post">>) {
-      return coreFetch<P, "post">(url, { ...init, method: "POST" } as any);
+    async POST<P extends PathsWithMethod<Paths, "post">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "post">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "POST";
+      return coreFetch<P, "post">(url, init as any, fetch);
     },
     /** Call a DELETE endpoint */
-    async DELETE<P extends PathsWithMethod<Paths, "delete">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "delete">>) {
-      return coreFetch<P, "delete">(url, { ...init, method: "DELETE" } as any);
+    async DELETE<P extends PathsWithMethod<Paths, "delete">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "delete">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "DELETE";
+      return coreFetch<P, "delete">(url, init as any, fetch);
     },
     /** Call a OPTIONS endpoint */
-    async OPTIONS<P extends PathsWithMethod<Paths, "options">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "options">>) {
-      return coreFetch<P, "options">(url, { ...init, method: "OPTIONS" } as any);
+    async OPTIONS<P extends PathsWithMethod<Paths, "options">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "options">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "OPTIONS";
+      return coreFetch<P, "options">(url, init as any, fetch);
     },
     /** Call a HEAD endpoint */
-    async HEAD<P extends PathsWithMethod<Paths, "head">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "head">>) {
-      return coreFetch<P, "head">(url, { ...init, method: "HEAD" } as any);
+    async HEAD<P extends PathsWithMethod<Paths, "head">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "head">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "HEAD";
+      return coreFetch<P, "head">(url, init as any, fetch);
     },
     /** Call a PATCH endpoint */
-    async PATCH<P extends PathsWithMethod<Paths, "patch">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "patch">>) {
-      return coreFetch<P, "patch">(url, { ...init, method: "PATCH" } as any);
+    async PATCH<P extends PathsWithMethod<Paths, "patch">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "patch">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "PATCH";
+      return coreFetch<P, "patch">(url, init as any, fetch);
     },
     /** Call a TRACE endpoint */
-    async TRACE<P extends PathsWithMethod<Paths, "trace">>(url: P, init: FetchOptions<FilterKeys<Paths[P], "trace">>) {
-      return coreFetch<P, "trace">(url, { ...init, method: "TRACE" } as any);
+    async TRACE<P extends PathsWithMethod<Paths, "trace">>(
+      url: P,
+      init: FetchOptions<FilterKeys<Paths[P], "trace">>,
+      fetch = globalThis.fetch
+    ) {
+      init.method = "TRACE";
+      return coreFetch<P, "trace">(url, init as any, fetch);
     },
   };
 }
@@ -142,10 +240,18 @@ export function defaultBodySerializer<T>(body: T): string {
 }
 
 /** Construct URL string from baseUrl and handle path and query params */
-export function createFinalURL<O>(url: string, options: { baseUrl?: string; params: { query?: Record<string, unknown>; path?: Record<string, unknown> }; querySerializer: QuerySerializer<O> }): string {
-  let finalURL = `${options.baseUrl ? options.baseUrl.replace(TRAILING_SLASH_RE, "") : ""}${url as string}`;
+export function createFinalURL<O>(
+  url: string,
+  options: {
+    baseUrl?: string;
+    params: { query?: Record<string, unknown>; path?: Record<string, unknown> };
+    querySerializer: QuerySerializer<O>;
+  }
+): string {
+  let finalURL = `${options.baseUrl ? options.baseUrl.replace(TRAILING_SLASH_RE, "") : ""}${url}`;
   if (options.params.path) {
-    for (const [k, v] of Object.entries(options.params.path)) finalURL = finalURL.replace(`{${k}}`, encodeURIComponent(String(v)));
+    for (const [k, v] of Object.entries(options.params.path))
+      finalURL = finalURL.replace(`{${k}}`, encodeURIComponent(String(v)));
   }
   if (options.params.query) {
     const search = options.querySerializer(options.params.query as any);
diff --git a/tsconfig.json b/tsconfig.json
index 5b4f2297b7ad4f856519c157c9781208758756c2..e331440ce3a218aa1bb35a48cd24bff9d052dec9 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -4,7 +4,7 @@
     "declaration": true,
     "downlevelIteration": false,
     "esModuleInterop": true,
-    "module": "ESNext",
+    "module": "NodeNext",
     "moduleResolution": "nodenext",
     "outDir": "dist",
     "skipLibCheck": true,
